# 2. 어떻게 해결할지 계획을 세운다.

- - 와일드 카드 처리가 곤란하다. \* 와일드 카드를 사용할지 말지 여부를 완전 탐색을 이용하여 처리해야한다.
- 완전 탐색 알고리즘을 설계한다.
  - 두 개의 문자열을 비교한다. 동일 여부를 boolean으로 반환한다.
- 동적 계획법으로 최적화한다.
  - 동적 계획법으로 최적화 할 수 있는 이유는 다음과 같다.
    - 카드를 한번 만나면, 비교 대상 문자열의 길이가 s라고 할 때 O(2^s)의 시간 복잡도가 소모된다. 그리고 이를 \* 와일드 카드의 개수에 곱한 것이 시간 복잡도이다.
    - 최악의 경우에 와일드 카드 문자열이 전부 `*`로 이루어져있다면, `O(n * 2^n)`의 시간이 소모될 것이다.
    - 우리에게 주어진 input은 100, 100이다. 따라서 모든 경우의 수는 `100 * 100` 이다.
    - 최대 나올 수 있는 경우의 수는 O(n^2)인데, 우리가 구하는 것은 O(2^n) 이므로 비둘기 논리에 의해서 동적 계획법을 적용할 수 있다.
    - cache를 이차원 배열 cache[i][j] 형태로 선언한다. i는 와일드 문자열의 시작 지점을 의미한다. j는 비교 문자열의 시작 지점을 의미한다.
    - 이러한 방식의 캐싱이 가능한 이유는, 접미사이기 떄문이다. 즉 시작 지점만 있으면 끝 지점은 항상 동일하기 때문이다.

# 3. 계획을 검증한다.

- 메모이제이션을 적용했기 때문에 시간 복잡도는 O(n^3)이다. 각각의 케이스마다, O(n^2) 검증을 해야하고, 이를 n번 하므로, O(n^3)이다.

# 4. 프로그램을 구현한다.

# 5. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
