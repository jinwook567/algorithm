# 1. 문제를 익숙한 용어로 재정의한다.

- board가 주어질 때, 맨 윗칸에서 맨 아래칸으로 이동할 수 있는지 여부를 구하라.
- 아래쪽 혹은 오른쪽으로 이동할 수 있다.

# 2. 어떻게 해결할지 계획을 세운다.

- 완전 탐색 알고리즘을 고안한다.
- 완전 탐색 알고리즘에서 중복되는 부분이 존재한다.
  - 오른쪽으로 가고, 아래로 갔을 때. 아래로 갔다가 오른쪽으로 갔을 때 우리는 동일한 어느 지점에 마주할 수 있다. 이 값은 재활용 될 수 있다.
  - 만일 board의 크기가 n이라면 완전 탐색은 최대 O(2^100) 경우의 수를 생성한다. 하지만 입력은 100 \* 100 = 10,000 뿐이다.
    - jump(a,b)는 a,b 위치에서 맨 아래쪽에 도달할 수 있음을 나타낸다. 실제로 만들 수 있는 모든 경우의 수는 jump(0~n, 0~n)이다.
    - 따라서 비둘기집 논리에 의해서 중복이 있음을 알 수 있다.

# 3. 계획을 검증한다.

# 4. 프로그램을 구현한다.

# 5. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
