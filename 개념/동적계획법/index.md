# 동적 계획법 용어

- 캐시: 계산한 값을 저장해두는 메모리 장소
- 중복되는 부분 문제: 두 번 이상 계산되는 부분 문제

# 동적 계획법이란

- 중복되는 부분 문제의 답을 캐싱하여, 똑같은 계산을 하지 않음으로써 속도의 향상을 꾀할 수 있는 방법
- 계산의 중복 횟수는 분할의 깊이가 깊어질수록 지수적으로 증가함.
- 동적 계획법을 적용하기 위해서는, 부분 문제의 정답이 항상 일정함이 보장되어야 함.
  - 즉 참조 투명한 함수이여야 함.
  - 어떤 input이 들어갔을 때, 항상 동일한 output이 나와야함.

# 메모이제이션 구현 패턴

- 한 가지 패턴을 정해두고 항상 같은 방식으로 작성하면 버그를 찾기 쉬워짐.
- 항상 기저 사례를 제일 먼저 처리한다.
  - 기저 사례를 확인하지 않고, cache에 접근하면 범위를 벗어나는 오류가 발생할 수 있음.
- cache의 초기값은 함수가 반환할 수 없는 값이어야함.
  - 만약에 함수가 boolean을 반환한다면, cache의 초기값은 false로 하면 안된다.  
    그 이유는 함수의 결과가 불가능인지, 아직 캐싱이 적용되지 않은 것인지 모르기 때문이다.
- ret이 cache에 대한 참조형이다. 하지만 js와 c++의 차이가 존재한다. 이 컨벤션은 따를 수 없다.
  - 해당 컨벤션을 따르기 위해서는, 메모이제이션 값을 전부 참조값으로 만들어주어야 한다.

# 메모이제이션 시간 복잡도

- 상한은 다음과 같다. `존재하는 부분 문제의 수 * 한 부분 문제를 풀 때 필요한 반복문의 수행 횟수`
- 만약에 메모이제이션이 없었다면, 중복되는 부분 문제의 필요한 반복문의 수행 횟수만큼 곱해주어야 한다.

# 테크닉

- 완전 탐색 알고리즘을 만들어보기(재귀 활용)
