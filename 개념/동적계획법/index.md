# 동적 계획법 용어

- 캐시: 계산한 값을 저장해두는 메모리 장소
- 중복되는 부분 문제: 두 번 이상 계산되는 부분 문제

# 동적 계획법이란

- 중복되는 부분 문제의 답을 캐싱하여, 똑같은 계산을 하지 않음으로써 속도의 향상을 꾀할 수 있는 방법
- 계산의 중복 횟수는 분할의 깊이가 깊어질수록 지수적으로 증가함.
- 동적 계획법을 적용하기 위해서는, 부분 문제의 정답이 항상 일정함이 보장되어야 함.
  - 즉 참조 투명한 함수이여야 함.
  - 어떤 input이 들어갔을 때, 항상 동일한 output이 나와야함.

# 메모이제이션 구현 패턴

- 한 가지 패턴을 정해두고 항상 같은 방식으로 작성하면 버그를 찾기 쉬워짐.
- 항상 기저 사례를 제일 먼저 처리한다.
  - 기저 사례를 확인하지 않고, cache에 접근하면 범위를 벗어나는 오류가 발생할 수 있음.
- cache의 초기값은 함수가 반환할 수 없는 값이어야함.
  - 만약에 함수가 boolean을 반환한다면, cache의 초기값은 false로 하면 안된다.  
    그 이유는 함수의 결과가 불가능인지, 아직 캐싱이 적용되지 않은 것인지 모르기 때문이다.
- ret이 cache에 대한 참조형이다. 하지만 js와 c++의 차이가 존재한다. 이 컨벤션은 따를 수 없다.
  - 해당 컨벤션을 따르기 위해서는, 메모이제이션 값을 전부 참조값으로 만들어주어야 한다.

# 메모이제이션 시간 복잡도

- 상한은 다음과 같다. `존재하는 부분 문제의 수 * 한 부분 문제를 풀 때 필요한 반복문의 수행 횟수`
- 만약에 메모이제이션이 없었다면, 중복되는 부분 문제의 필요한 반복문의 수행 횟수만큼 곱해주어야 한다.

# 테크닉

- 완전 탐색 알고리즘을 만들어보기(재귀 활용)

# 최적화 문제란?

- 여러 개의 가능한 답 중 가장 좋은 답(최적해)를 찾는 문제
- 최적 부분 구조: 어떤 문제와 분할 방식에 성립하는 조건. 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 조건이 성립  
  (지금까지의 선택과 상관 없이 각 부분 문제를 최적으로 풀면 전체 문제의 최적해도 알 수 있음.)

# 최적화 문제 동적 계획법 레시피

1. 완전 탐색 알고리즘을 설계한다.
2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꾼다. (최적 부분 구조를 만족하도록)
3. 재귀 호출의 입력에 이전 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 줄인다.  
   -> 메모이제이션을 최대로 활용할 수 있다. 인자의 조합으로 메모이제이션을 구성할 수 있기 때문에.
4. 입력이 배열 또는 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션 할 수 있도록 한다.
5. 메모이제이션을 적용한다.
