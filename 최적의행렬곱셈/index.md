---
category: d
url: https://school.programmers.co.kr/learn/courses/30/lessons/12942
---

# 문제 접근

기본 이해: `(a,b), (b,c)`라는 두개의 행렬을 곱하면 `(a,c)`라는 새로운 행렬이 탄생한다.

1.  처음에 생각한 알고리즘은, 어떠한 두 행렬을 곱하면, 가운데 요소(b)를 한번만 곱해도 된다. 가운데 요소가 큰 것을 먼저 찾아서 곱하는 그리디한 방식으로 문제를 풀면, 정답이 나올 것이다.

    - 가장 큰 b를 찾아 연산을 먼저 수행한다고 해도 이게 최소라는 보장은 사실상 없다.
    - (a,b), (b,c), (c,d) 가 존재한다고 할 때 c가 최댓값이라고 하면, 1번식은 나의 알고리즘을 적용한 값이다. 아래의 식에서, 1번이 2번보다 무조건 작다고 수학적으로 증명할 수 없다.

      1. `b * c * d + a * b * d`
      2. `a * b * c + a * c * d`

2.  어떠한 방식으로 계산 했을 때, 최솟값을 찾는 알고리즘은 모르겠다. 그렇다면 모든 계산을 해보는 수밖에 없다. 행렬의 개수가 200이므로, 최대 시간 복잡도는 O(199!)이다. 시간 복잡도를 줄일 수 있는 방안을 생각해봐야 한다. 다이나믹 프로그래밍을 활용할 수 있다. 다이나믹 프로그래밍을 활용할 수 있는 이유는 다음과 같다.

    - (i,j)까지의 행렬이라고 할 때, 연산을 수행하고 나면 무조건 i의 첫 번째 원소, j의 2번째 원소를 보유한 행렬이 생긴다.
    - i부터 j까지 행렬의 최솟값은 재활용 될 수 있다. (작은 문제의 해답이 큰 문제의 해답 중 일부읻.)
    - i부터 j까지의 행렬 배열의 최댓값을 구하는 방법은, 임의의 중간 지점을 정해서 2개의 행렬을 가진 배열로 쪼개버린다. 쪼개진 배열은 결국에 어떠한 하나의 행렬로 귀결될 것이고 귀결된 행렬들끼리 곱해본다. 그리고 이게 최소인지 확인한다.

3.  행렬 i부터 j까지의 최소 연산 횟수를 구하는 로직은 재귀를 활용하면 간단하다. 기저 조건은 i부터 j까지의 메모해둔 최소 연산이 존재하거나, i와j가 인접했을 경우이다.
