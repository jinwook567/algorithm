---
category: dp
url: https://school.programmers.co.kr/learn/courses/30/lessons/12907
---

# 문제 접근

위 문제는 dp이다. 이유는 아래와 같다.

1. 완전 탐색으로 정답을 구하기 위해서는 O(2^n) 시간 복잡도가 필요하다. 화폐의 단위는 최대 100이다.
   - 완전 탐색의 경우, O(2^100)로 시간 초과가 발생한다.
2. 큰 문제를 작은 문제로 쪼갤 수 있다. 쪼개진 문제는 큰 문제의 정답의 일부로 활용될 수 있다.
   - 만약에 1과 2를 사용하여, 3을 만들 수 있는 개수를 생각해봤을 때, `[1,1,1]`, `[1,2]` 총 2가지이다.
   - 만약에 4를 만든다고 가정하면, 3원에서 1원을 더해서 내는 경우, 2원에서 2원을 더해서 내는 경우를 생각해볼 수 있다.
   - 3원에서 1원을 더해서 내는 경우를 생각해보면, 3원을 만들 수 있는 경우의 수와 동일하다. `[1,1,1,1]`, `[1,2,1]` 기존의 3원을 만들 수 있는 방식에 1을 추가해주면 되는 것이다.
   - 2원에서 2원을 더해서 내는 경우도 마찬가지이다. 2원을 낼 수 있는 모든 경우에서, 2를 더해준 것과 같다.

해당 유형이 dp라는 것을 깨달았으니, 점화식을 세워봐야한다.  
`d[i]`는 화폐 단위 m(배열)를 사용하여 숫자 i를 만들 때 그 최대 개수를 의미한다.  
`d[i] = d[i] + d[i - unit] (unit은 m 배열의 원소)`

위의 점화식이 세워진 이유는, unit이 더해지기 전 케이스에 unit을 더한 것이기 때문에 경우의 수는 동일하다. (순서가 관계 없으므로.)

# 코드 설명

- d라는 배열 형태의 자료 구조를 정의하였음. 초기값은 0.
- `d[0]`은 1을 삽입해주었음. 그 이유는, 1원을 가지고 1원을 만들 때 `d[1] = d[1] + d[0]` 이라는 식이 성립하는데 `d[0]`을 1로 만들어주어서, 하나의 코드로 모든 상황을 커버할 수 있도록 하였음. 만약에 이렇게 처리하지 않으면 화폐를 순회하면서 해당되는 단위의 d의 인덱스에 1을 삽입 해주어야함.
- (가장 중요한 파트) money를 먼저 순회하면서 d를 만들어나감. d를 순회하면서 money를 또 순회하는게 아님. 후자의 경우로 처리하면 놓는 순서에 따라 달라지는 것으로 간주하는 것임. 전자로 처리해야 중복의 경우가 없게됨.
