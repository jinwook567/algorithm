# 2. 어떻게 해결할지 계획을 세운다.

- 우선 완전 탐색 알고리즘을 생각해본다.

  - 재귀를 이용한다.
  - 문제를 정의한다: pi의 최소 난이도를 구하라.
  - 기저 케이스: pi가 존재하지 않을 때 난이도는 0이다.
  - 알고리즘: 3,4,5개로 자른다. 그리고 난이도를 구한다. 그리고 이를 자르고 남은 pi에 대해서 재귀를 호출한다.

- 완전 탐색 알고리즘은 시간 복잡도를 초과한다.
- 동적 계획법 알고리즘을 고안해본다.
  - 우리에게 주어지는 index는 n개이다. 하지만 완전 탐색 알고리즘 시간 복잡도는 O(n^3)이다.
  - 비둘기집 논리에 의해서 중복되는 부분이 있다.
  - 캐싱 전략을 사용하여 중복되는 계산을 하지 않는다.
  - 어떤 i를 pi의 임의의 위치라고 할 때, i를 기준으로 자른다. 이 때 각각의 pi는 최적 부분 구조가 성립한다.
  - 따라서 cache를 정의하는데, `cache[i]`는 i 위치에서 최소 난이도를 의미한다.
  - 정답은 cache[0]을 반환하면 된다.
  - 동적 계획법 알고리즘을 사용할 때, cache의 내부 요소는 참조값을 사용하기 위하여 객체로 정의한다.

# 3. 계획을 검증한다.

- 완전 탐색 알고리즘의 경우 O(n^3)으로 n은 최대 10,000으로 불가능하다.
- 동적 계획법 알고리즘의 경우 O(n)이다. 우리에게 주어진 것이 n뿐이므로. n을 다 만들면, 알고리즘을 종료한다.

# 4. 프로그램을 구현한다.

# 5. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
