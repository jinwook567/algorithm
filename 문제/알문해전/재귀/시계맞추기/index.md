# 1. 문제를 익숙한 용어로 재정의한다.

- 16개의 시계가 있다.
- 스위치는 시계들과 연결되어 있는데, 누르면 3시간씩 밀어버린다.
- 16개의 시계가 전부 12시를 가르키게 하고 싶다. 이 때 최소의 스위치 누른 횟수를 구하여라.
- 불가능한 경우에는 -1을 리턴하라.

# 2. 어떻게 해결할지 계획을 세운다.

- 완전 탐색 혹은 그리디 문제로 추정된다.
- 우선 완전 탐색으로 알고리즘을 설계해본다.
- 스위치는 9개가 존재한다. 따라서 O(9^n) 시간 복잡도를 가진다.

  - 문제를 정의한다: 스위치와, 시계가 주어졌을 때 최소 스위치 횟수를 구하라.
  - 기저 케이스

    - 시계가 모두 12시를 가르킨다.
    - 타이머를 어떻게 누르던 불가능한 경우는, 비둘기 논리를 이용한다.  
      모든 타이머를 4번 누르면 다시 원래 제자리로 돌아온다. 따라서 하나의 타이머라도 4번을 넘기면 이는 최소 조건이 아니므로, 종료시킨다.
    - 결국에는 모든 타이머를 최대 0-3번 눌러보는 모든 경우의 수를 넘어간다면, 이는 성립하지 않는다는 의미이다.

  - 변경되는 것들을 인수로 설정한다. : 각 버튼을 누른 횟수, 시계의 상태, 현재 눌러야 하는 버튼
  - 우리는 버튼을 누르는 최소 횟수만 관심이 있다. 버튼은 + 연산이므로, 교환법칙이 성립한다. 순서를 신경쓰지 않아도 좋다.
    - 특정한 상황만을 고려한다. 왼쪽에 위치하는 스위치는 누르지 않도록 한다. 오른쪽 스위치만 누른다.
    - 버튼을 안누르고 넘어갈수도 있다. 따라서 현재 눌러야 하는 버튼의 위치를 인수로 넘겨주고, 버튼의 위치가 초과했다면 종료한다.

# 3. 계획을 검증한다.

- 스위치를 누를 수 있는 방법은 최대 0-3회로 4번이다. 따라서 `4^10`의 시간 복잡도를 가지며, 완전 탐색으로 풀기에 충분하다.

# 4. 프로그램을 구현한다.

# 5. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

- 스위치를 다시 뒤로 돌리기보다는, 그냥 스위치를 4번 눌러서 원상복구 해주는 알고리즘으로 저자는 작성했다. 훨씬 간결한 풀이인 것 같다.
- 또한 횟수만큼 스위치를 눌러주고 빼주는 로직을 수행하기 보다는, 스위치를 한번씩 눌러주는 식으로 작업을 수행한다. 훨씬 코드가 간결해진다.
  - 함수의 기능을 최대한 작게 만들고, 기존 함수를 최대한 활용한다는 점에서 코드가 매우 깔끔하다.
- 나의 재귀 알고리즘은 동작하기는 하지만, 기저 케이스가 문제의 정의와 일치하지 않는다. 기저 케이스는 최소 횟수가 아닌, 만들 수 있는 횟수를 리턴한다.
  - 기저 케이스도 문제의 정의를 만족해야한다. 그렇게 해야 재귀 관련 코드가 매우 간결해지며, 재귀에 관한 철학이 일치한다.
  - res를 구하는 로직에서, 처리를 해준다. (큰 문제를 작은 부분으로 나눈 것이고, 이를 활용해서 정답을 도출한다는 것을 잊지말라.)
