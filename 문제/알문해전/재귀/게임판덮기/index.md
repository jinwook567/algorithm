# 1. 문제를 익숙한 용어로 재정의한다.

- H,W 크기 이중 배열이 있고, 검은 칸과 힌 칸이 있음.
- L자 모양의 흰색 블록으로 만들 것. 회전 가능함.
- 단 겹치거나, 검은 칸 덮거나, 게임판 밖으로 나가서는 안됨.
- 방법의 수를 구하시오.
- H,W 1 이상, 20 이하 흰칸 수 최대 50
- #는 검은 칸, .는 흰 칸

# 2. 어떻게 해결할지 계획을 세운다.

- 검은 칸은 1, 흰 칸은 0이라고 하겠음. H,W 배열 내 모든 원소를 1로 만들어야함.
- 완전 탐색을 이용해서 문제를 해결해본다.
- 재귀를 이용한다.
  - 문제 선언: 격자와 남은 흰 칸의 개수를 인자로 받았을 때, 가능한 경우의 수를 구하라.
  - 기저 케이스: 흰 칸의 개수가 0일 경우에는 1을 반환한다.
  - 기저 케이스: 남은 칸의 개수가 3의 배수가 아니라면, 0을 반환한다. L은 3칸이고, 중복이 안되기에 3의 배수가 아니라면 전부 채워넣을 수 없다.
  - 재귀의 경우를 전부 더해준다.
- 우리는 중복의 경우는 제외시켜야한다. 중복의 경우를 제외시키려면 특정한 경우만 고려하면 된다.
  - 위에서 아래 순서로 L자를 넣어보는 작업을 수행한다.
  - 현재보다 (y,x) 이전에 위치한 격자는 고려하지 않는다.
- 회전된 격자를 4개 미리 만들어 놓는다.
- 만약 더해진 부분이 1 이상이라면 해당 케이스는 고려하지 않는다.

# 3. 계획을 검증한다.

- 이론적으로는 `4 ^ (50/3)` 시간 복잡도를 가진다.
- 하지만 사방에 가로막혀 넣을 수 없는 경우도 존재하며, L자 위치에 전부 흰색 이여야 하기에 제약이 존재한다.
- 이러한 검증은 문제의 예시 조건들을 통해서 유추할 수 있다. 흰 칸이 48개 있는 세 번째 예제 입력의 답이 1514밖에 되지 않는다.

# 4. 프로그램을 구현한다.

# 5. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

- 코드를 작성하면서, 적정한 수준으로 함수를 추출하기 위해서는, 반복문 내부를 추출해야 한다고 생각했다. 그리고 저자의 정답 코드는 그러했다.
  - 나의 경우에는 set 함수가 더해주고 빼주고를 전부 처리해주려고 했다. 그리고 그 사이에 로직을 cb 함수로 받으려고 하였다. 뭐 이것도 좋은 방법인 것 같다.
  - 저자는 delta라는 인자를 추가로 받아서, 더해주고 빼주고를 컨트롤 할 수 있게 하였다.
- 전역 변수를 사용해도 좋다. 하지만 전역 변수를 사용할 때는 절대 값을 변경시키면 안된다. 그리고 이 전역 변수는 최상단에 위치시키는 convention을 가지자.
- 나의 코드는 약간 최적화된 코드이다. 하지만 코드 자체가 너무 복잡해졌다. 시간 복잡도를 계산해보고, 코드의 최적화가 필요없다면 할 필요가 없다.
  - 저자의 경우 시작하는 위치를 재귀함수에서 받아오지 않고, 단순하게 처음 흰색 블록이 나타나는 시점으로 처리하였다.
  - 처리했던 배열들을 순회하느라 약간의 시간 복잡도가 소모되지만, 이 떄문에 시간 복잡도를 초과하지는 않는다.
- 완전 탐색은 피지컬을 요하는 경우가 많다. 피지컬을 요하는 문제는 코드가 더러워지기 일 수 이다. 코드 컨벤션, 정답을 통과하는 수준에서 가장 깔끔한 코드를 작성해야한다. (알고리즘에서 섣부른 최적화는 금물이다.)
